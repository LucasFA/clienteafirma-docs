<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>AF manual desarrollo plugins ES - My Docs</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "AF manual desarrollo plugins ES";
        var mkdocs_page_input_path = "markdown_strict/AF_manual_desarrollo_plugins_ES.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> My Docs
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Welcome to MkDocs</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Markdown strict</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../AF_Firmar_AutoFirma_Linux/">AF Firmar AutoFirma Linux</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AF_Firmar_AutoFirma_OS_X/">AF Firmar AutoFirma OS X</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AF_Instalador%20Linux/">Preparación del entorno</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AF_Instalador%20Mac%20OS%20X/">AF Instalador Mac OS X</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AF_Instalador%20Windows/">AF Instalador Windows</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">AF manual desarrollo plugins ES</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#integracion-en-el-proceso-de-firma-desde-la-interfaz-grafica">Integración en el proceso de firma desde la interfaz gráfica</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#preprocesando-los-datos-que-se-van-a-firmar">Preprocesando los datos que se van a firmar</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#postprocesado-de-la-firma-generada">Postprocesado de la firma generada</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#integracion-en-el-proceso-de-firma-mediante-protocolo">Integración en el proceso de firma mediante protocolo</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#preconfiguracion-de-la-firma">Preconfiguración de la firma</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#composicion-de-la-respuesta-de-firma">Composición de la respuesta de firma</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#integracion-en-las-pantallas-de-firma">Integración en las pantallas de firma</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#botones-de-accion">Botones de acción</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#menu">Menú</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#nuevos-comandos">Nuevos comandos</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#configuracion-de-los-plugins">Configuración de los plugins</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AF_manual_instalacion_usuarios_ES/">AF manual instalacion usuarios ES</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AF_manual_instalacion_y_gestion_ES/">AF manual instalacion y gestion ES</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ANEXO_Firma-electronica-en-varias-fases/">Firma electrónica en tres fases</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_arquitectura_ES/">CF arquitectura ES</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_catalogo_aplicaciones/">CF catalogo aplicaciones</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_distribuciones/">CF distribuciones</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_funcional_ES/">CF funcional ES</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_guia-incidencias/">CF guia incidencias</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_guia-uso-interfaz/">CF guia uso interfaz</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_guia-uso/">CF guia uso</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_manual-firmas-pdf/">CF manual firmas pdf</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_manual-firmas-xml/">CF manual firmas xml</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_manual-integrador/">CF manual integrador</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_manual-migracion/">CF manual migracion</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_manual_integracion_modulos_ES/">CF manual integracion modulos ES</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_plan-pruebas/">CF plan pruebas</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../CF_roadmap_ES/">CF roadmap ES</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Comunicacion_Navegador_y_App_en_Entorno_Movil/">El camino de ida: Desde el navegador Web hacia la App</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../DECLARACION_ACCESIBILIDAD/">Declaración de Accesibilidad</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Diagramas%20de%20secuencia%20de%20los%20procesos%20de%20firma%20m%C3%B3vil/">Firma monofásica (Windows 8 / Windows RT y Android)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Firma_por_lotes_predefinidos_con_el_MiniApplet_Cliente/">Firma por lotes predefinidos con el MiniApplet Cliente</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Informe%20-%20Alternativas_Applets_para_firma/">Informe   Alternativas Applets para firma</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Invocaci%C3%B3n%20por%20protocolo%20de%20aplicaciones%20nativas%20desde%20p%C3%A1ginas%20Web/">¿Qué es la invocación por protocolo?</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../La_seguridad_en_el_Servicio_de_firma_del_Cliente/">Tabla de contenido</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../MCF_manual-integrador_ES/">MCF manual integrador ES</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../MCF_roadmap_ES/">MCF roadmap ES</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Manual%20para%20la%20configuraci%C3%B3n%20de%20los%20campos%20de%20firma%20para%20la%20aplicaci%C3%B3n%20de%20firma%20manuscrita%20en%20tableta/">Manual para la configuración de los campos de firma para la aplicación de firma manuscrita en tableta</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../PF_Manual_App_Portafirmas_Android/">PF Manual App Portafirmas Android</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../PF_Manual_App_Portafirmas_iOS/">PF Manual App Portafirmas iOS</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../PF_manual-configuracion_servicios_ES/">PF manual configuracion servicios ES</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Sintaxis_invocacion_Cliente_Afirma/">Sintaxis invocacion Cliente Afirma</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../afirma_movil_intro/"><<img src="media/image1.jpeg"</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">My Docs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Markdown strict</li>
      <li class="breadcrumb-item active">AF manual desarrollo plugins ES</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <p>AutoFirma es una herramienta de escritorio con interfaz gráfica que
permite la ejecución de operaciones de firma de ficheros locales en
entornos de escritorio (Windows, Linux y OS X). También puede utilizarse
a través de consola o ser invocada por otras aplicaciones mediante
protocolo para la ejecución de operaciones de firma. Esta última
funcionalidad puede usarse principalmente mediante el JavaScript de
despliegue del Cliente @firma, que permitiría que se utilizase AutoFirma
para generar las firmas de un trámite web.</p>
<p>AutoFirma incluye un sistema básico de <em>plugins</em> que permiten modificar
el comportamiento de las operaciones de firma y proporcionar nueva
funcionalidad cuando se utiliza como aplicación de escritorio. Es decir,
los <em>plugins</em> sólo se activan cuando la aplicación se ejecuta en modo
gráfico. No afecta a las operaciones de firma cuando se invoca desde
otra aplicación (como un navegador web) ni cuando se ejecuta mediante
línea de comandos.</p>
<p>Un <em>plugin</em> consiste en una biblioteca Java que extiende una clase
concreta y que proporcionar un fichero JSON con la información necesaria
para la integración con AutoFirma. El desarrollo del <em>plugin</em> requiere
labores de programación, mientras que la instalación y desinstalación de
los <em>plugins</em> puede ser llevada a cabo por los usuarios de AutoFirma.</p>
<p>El mecanismo de <em>plugins</em> actual podría modificarse en un futuro para
permitir nuevas funcionalidades y opciones de integración.</p>
<p>AutoFirma es una aplicación de Software Libre que se puede usar, a su
elección, bajo licencia <em>GNU General Public License</em> versión 2 (GPLv2) o
superior o bajo licencia <em>European Software License</em> 1.1 (EUPL 1.1) o
superior.</p>
<p>AutoFirma puede descargarse desde el Portal de Administración
Electrónica:</p>
<p><a href="https://firmaelectronica.gob.es/Home/Descargas.html">https://firmaelectronica.gob.es/Home/Descargas.html</a></p>
<p>El código fuente de AutoFirma se encuentra disponible desde el
repositorio público de GitHub:</p>
<p><a href="https://github.com/ctt-gob-es/clienteafirma">https://github.com/ctt-gob-es/clienteafirma</a></p>
<h1 id="alcance-funcional-de-los-plugins">Alcance funcional de los <em>plugins</em></h1>
<p>Un usuario puede instalar, configurar y desinstalar <em>plugins</em> de
AutoFirma.</p>
<p>Al instalar un <em>plugin</em>, el fichero de <em>plugin</em> se copia en el
directorio de AutoFirma, se ejecuta un proceso de instalación definido
por el propio <em>plugin</em> y, a partir de ese momento, el <em>plugin</em> pasa a
estar activo y podrá afectar a los procesos de firma y mostrar botones
en las pantallas de AutoFirma.</p>
<p>En el proceso de instalación se comprueban los permisos solicitados por
el plugin. Un plugin no puede integrarse de un modo concreto si no ha
solicitado el permiso necesario para ello en el proceso de instalación.</p>
<p>Los <em>plugins</em> pueden implementar una interfaz gráfica de configuración.
En caso de hacerlo, en el mismo diálogo de gestión de <em>plugins</em>,
aparecerá un botón de configuración para iniciar esta interfaz. Con
ella, el usuario deberá poder establecer los aspectos configurables del
<em>plugin</em>.</p>
<p>Al desinstalar un <em>plugin</em>, se ejecuta un proceso de desinstalación
definido por el propio <em>plugin</em>, se descarga de memoria y, finalmente,
se elimina del directorio de AutoFirma.</p>
<p>Los <em>plugins</em> se integran con AutoFirma de las siguientes formas:</p>
<ul>
<li>
<p>Integración en el proceso de firma desde la interfaz gráfica.</p>
<ul>
<li>
<p>El <em>plugin</em> puede afectar a las operaciones de firma de dos
    formas:</p>
<ul>
<li>
<p>Preprocesando los datos a firmar.</p>
</li>
<li>
<p>Postprocesando las firmas generadas.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Integración en el proceso de firma iniciada mediante protocolo desde
    una aplicación externa.</p>
<ul>
<li>
<p>El <em>plugin</em> puede afectar a las operaciones de firma de dos
    formas:</p>
<ul>
<li>
<p>Preconfiguración de la operación de firma, pudiendo dividir
    ésta en varias operaciones.</p>
</li>
<li>
<p>Composición de los datos a devolver a partir de las firmas
    generadas.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Integración en las pantallas de AutoFirma.</p>
<ul>
<li>
<p>Pueden agregarse botones que pueden aparecer en diversas
    pantallas de la aplicación y asignarles un comportamiento. Los
    botones pueden aparecer en las siguientes pantallas:</p>
<ul>
<li>
<p>Carga de datos</p>
</li>
<li>
<p>Resultado de firma.</p>
</li>
<li>
<p>Resultado de firma masiva.</p>
</li>
<li>
<p>Visualización de datos de firma.</p>
</li>
</ul>
</li>
<li>
<p>Puede definirse un menú que aparezca en la barra de menús de la
    aplicación, definir submenús sobre el mismo y acciones que
    ejecutar con cada una de sus opciones.</p>
</li>
</ul>
</li>
<li>
<p>Nuevos comandos por línea de comandos:</p>
<ul>
<li>Se puede agregar nuevos comandos para ejecutarlos desde la línea
    de comandos.</li>
</ul>
</li>
</ul>
<h2 id="integracion-en-el-proceso-de-firma-desde-la-interfaz-grafica">Integración en el proceso de firma desde la interfaz gráfica</h2>
<p>Un <em>plugin</em> puede intervenir en el proceso de firma que se ejecuta desde
la interfaz gráfica preprocesando los datos que se van a firmar o
postprocesando las firmas generadas. Este <em>plugin</em> es libre de mostrar
diálogos gráficos durante su ejecución, ya sean bloqueantes (por
ejemplo, cuando se solicite confirmación o un dato al usuario) o no (por
ejemplo, un diálogo de espera).</p>
<table>
<thead>
<tr>
<th><strong>IMPORTANTE</strong>: No existe limitación al número de <em>plugins</em> instalados que pueden efectuar esta operación y su ejecución siempre se realizará según el orden de carga. Es decir, si tuviésemos varios <em>plugins</em> que preprocesasen los datos antes de firmar, el primer <em>plugin</em> que se cargue podrá modificarlos, el segundo recibirá la salida del primero, el tercero la salida del segundo y así sucesivamente.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Por regla general, sólo se debería tener instalado un <em>plugin</em> que
preprocese los datos o postprocese la firma y debería ser este el que
ejecutase todas las operaciones sobre ambos elementos.</p>
<h3 id="preprocesando-los-datos-que-se-van-a-firmar">Preprocesando los datos que se van a firmar</h3>
<p>El método de preprocesado de datos nos permite obtener los datos del
fichero que cargó el usuario, devolver a la aplicación los datos que
realmente se firmarán y reconfigurar la propia operación de firma. Esto
es útil si deseamos restringir o condicionar los datos que se firman en
nuestro organismo.</p>
<p>Algunos ejemplos en los que se podría necesitar esta operación serían:</p>
<ul>
<li>
<p>Si los documentos PDF que se firmasen en el organismo siempre deben
    declarar una serie de metadados.</p>
<ul>
<li>Se podría implementar el método para que detectase cuando la
    firma a realizar es PAdES, modificase los PDF que vamos a firmar
    (previa comprobación de que no incluye firmas anteriores),
    agregase los metadatos necesarios y lo devolviese modificado.</li>
</ul>
</li>
<li>
<p>Si se desease que el usuario seleccionase por cada operación si
    quiere que las firmas CAdES sean implícitas (incluyan los datos) o
    explicita (no los incluyan).</p>
<ul>
<li>Se podría implementar el método para que detectase cuando la
    firma a realizar es CAdES, mostrarse un diálogo al usuario de
    consulta al usuario y, según lo respondido, modificase la
    configuración para que la firma fuese implícita o explícita.</li>
</ul>
</li>
</ul>
<h3 id="postprocesado-de-la-firma-generada">Postprocesado de la firma generada</h3>
<p>El método de postprocesado de firma nos permite modificar una firma
generada antes de que se guarde a disco. Este mecanismo recibe la firma
generada y cierta información sobre ella y devuelve los datos que
finalmente se almacenaran.</p>
<p>Algunos ejemplos en los que se podría utilizar esta aplicación serían:</p>
<ul>
<li>
<p>Si todas nuestras firmas deben contener un sello de tiempo,
    independientemente de que no se presenten ante una entidad.</p>
<ul>
<li>Se podría implementar un método para tomase la firma generada,
    conectase contra una TSA, generase un sello de tiempo y lo
    insertase en la firma. Después devolvería la firma ya con el
    sello.</li>
</ul>
</li>
<li>
<p>Si en nuestro organismo todas las firmas se debiesen guardar en un
    repositorio o gestor en la nube.</p>
<ul>
<li>Se podría implementar este método para que preguntase al usuario
    si desea enviar la firma al gestor. Si el usuario respondiese
    afirmativamente, se podría enviar la firma al servicio remoto.
    Ya se envíe o no la firma, se devolvería la propia firma y sería
    esta la que se guardaría en disco.</li>
</ul>
</li>
</ul>
<h2 id="integracion-en-el-proceso-de-firma-mediante-protocolo">Integración en el proceso de firma mediante protocolo</h2>
<p>Un <em>plugin</em> puede definir un modo de intervenir en el proceso de firma
cuando se ejecuta desde una aplicación externa en una llamada por
protocolo. En este caso, puede definir los parámetros de la operación de
firma (datos y configuración), incluso realizar múltiples firmas a
partir de una única llamada. Los datos resultantes de las operaciones de
firma son devueltos al plugin y es este el que define la respuesta al
cliente que realizó la operación.</p>
<p>La operación definida por el plugin se ejecutará cuando se cumpla una
condición de activación también prefijada por él. Así, si hubiese varios
plugin que definiesen un comportamiento a ejecutar durante la firma,
sólo se activaría aquel para el que primero se cumpliese la condición de
activación.</p>
<h3 id="preconfiguracion-de-la-firma">Preconfiguración de la firma</h3>
<p>Una vez se activa, el plugin recibe los datos recibidos para la
configuración de la operación (los datos a firmar, el formato, el
algoritmo...), así como cualquier parámetro adicional que se haya
enviado con la petición y que pueda servir para definir cómo se debe
operar. En base a esta configuración, el plugin definirá una serie de
configuraciones de firma que son las que realmente se van a aplicar.
Esto nos permitiría establecer mediante un plugin una serie de
configuraciones de firma preestablecidas o definir múltiples operaciones
de firma en una sola llamada a AutoFirma.</p>
<p>Algunos ejemplos en los que se podría necesitar esta operación serían:</p>
<ul>
<li>
<p>Su se desease permitir que AutoFirma realizase una operación de
    firma masiva a raíz de una única llamada:</p>
<ul>
<li>Se podrían enviar múltiples datos concatenados en el parámetro
    de datos, subdividirlos mediante la operación de
    preconfiguración y aplicar la misma configuración de firma a
    todos ellos.</li>
</ul>
</li>
<li>
<p>Si se desease que las operaciones de firma de nuestro organismo
    fueran homogéneas o que se pudiesen reconfigurar sin necesidad de
    modificar las aplicaciones web:</p>
<ul>
<li>Se podrían incorporar al plugin las configuraciones de firma
    deseadas y aplicarlas cuando se detecte un parámetro de
    configuración concreto enviado por la aplicación.</li>
</ul>
</li>
</ul>
<h3 id="composicion-de-la-respuesta-de-firma">Composición de la respuesta de firma</h3>
<p>El método de composición de la respuesta permite definir cuál es el
resultado que se devolverá a la aplicación cliente. Para componer este
resultado puede utilizarse el conjunto de firmas generada y la
configuración de firma inicial. Este dato será procesado por el
JavaScript de despliegue con el que se haya hecho la integración. Así
pues, es necesario devolver un resultado compatible con el mismo o
utilizar un JavaScript propio o modificado que se adapte a la respuesta
que se desea devolver.</p>
<p>Algunos ejemplos en los que se podría utilizar esta aplicación serían:</p>
<ul>
<li>
<p>Su se desease permitir que AutoFirma realizase una operación de
    firma masiva a raíz de una única llamada:</p>
<ul>
<li>Se podrían componer el resultado con todas las firmas y utilizar
    un JavaScript de despliegue adaptado para que separe las firmas
    generadas. En el caso de una firma trifásica, ni siquiera
    tendría que ser necesaria la adaptación de la respuesta.</li>
</ul>
</li>
<li>
<p>Si en nuestro organismo debiesen aplicarse medidas de seguridad
    adicionales sobre las firmas:</p>
<ul>
<li>Se podría implementar en este método los mecanismos adicionales
    de seguridad, como el uso de algoritmos de cifrado seguro a
    partir de una clave proporcionada por la propia aplicación. De
    esta forma, la firma viajaría cifrada todo el tiempo y no se
    descifraría hasta llegar al servidor de destino.</li>
</ul>
</li>
</ul>
<h2 id="integracion-en-las-pantallas-de-firma">Integración en las pantallas de firma</h2>
<h3 id="botones-de-accion">Botones de acción</h3>
<p>Los <em>plugins</em> pueden agregar botones en una barra para tal fin en
algunas de las pantallas de AutoFirma. Estos botones pueden ejecutar
procesos separados de la propia generación de la firma electrónica y
acceder a la información de la pantalla en cuestión.</p>
<p>&lt;<img src="media/image1.png"
style="width:6.22153in;height:4.89306in" /></p>
<p>Las acciones asignadas a los botones agregados pueden mostrar diálogos
gráficos durante su ejecución, ya sean bloqueantes (por ejemplo, cuando
se solicite confirmación o un dato al usuario) o no (por ejemplo, un
diálogo de espera). Incluso pueden mostrar un diálogo que permita
realizar operaciones completas totalmente independientes del proceso de
firma.</p>
<p>Algunos ejemplos de utilidad para esta función serían:</p>
<ul>
<li>
<p>Si en nuestro organismo trabajamos con un tipo de fichero concreto,
    por ejemplo, facturas electrónicas, se podría crear un <em>plugin</em> que
    agregue un botón a la pantalla de carga de datos y que permitiese al
    usuario que va a firmar pulsarlo para visualizar los datos cargado
    de tal forma que simplifique determinar si debe firmarse o no.
    Siguiendo el mismo ejemplo, se podría mostrar una relación con los
    conceptos y precios de la factura junto con los datos del proveedor.</p>
</li>
<li>
<p>Si queremos realizar una validación completa de todas nuestras
    firmas, se podría implementar un <em>plugin</em> que agregue un botón a la
    pantalla que muestra el resultado de la firma. Al pulsar ese botón
    se leería la firma y se enviaría a un servicio remoto encargado de
    validarla.</p>
</li>
<li>
<p>Si quisiésemos agregar una funcionalidad a AutoFirma que nada tiene
    que ver con la firma (por ejemplo, generación de <em>hashes</em> de
    ficheros), se podría implementar un <em>plugin</em> que agregue un botón a
    todas las pantallas que lo permiten y que, al pulsarlo, por ejemplo,
    muestre un diálogo modal que ofrezca la funcionalidad deseada.</p>
</li>
</ul>
<p>Las pantallas a las que se pueden agregar acciones en botón son:</p>
<ul>
<li>
<p>Pantalla de carga de datos</p>
<ul>
<li>Permite procesar los datos de entrada y el formato de firma que
    se va a emplear.</li>
</ul>
</li>
<li>
<p>Pantalla de resultado de una firma simple.</p>
<ul>
<li>Permite procesar la firma generada, el formato de firma
    empleado, los certificados contenidos por la firma y el
    certificado utilizado para firmar.</li>
</ul>
</li>
<li>
<p>Pantalla de resultado de un proceso de firma masiva.</p>
<ul>
<li>Permite procesar las firmas generadas, el formato de firma
    empleado para cada uno de ellos, los certificados contenidos por
    la firma y el certificado utilizado para firmar.</li>
</ul>
</li>
<li>
<p>Pantalla del visor de firma.</p>
<ul>
<li>Permite procesar la firma mostrada, su formato y el árbol de
    firmantes contenido en la misma.</li>
</ul>
</li>
</ul>
<h3 id="menu">Menú</h3>
<p>Los <em>plugins</em> permiten crear un menú propio en la barra de menús de la
aplicación. Este menú sería visible desde todas las pantallas de la
aplicación en las que se muestra la barra.</p>
<p>Las opciones de este menú pueden ser submenús o tener asociadas
acciones. Estas acciones permiten ejecutar operaciones independientes.
No reciben información de la pantalla que se muestra actualmente en la
aplicación como hacen los botones.</p>
<p>Esta funcionalidad está orientada a ampliar el funcionamiento de
AutoFirma. Por ejemplo, ha permitido externalizar a un plugin la
funcionalidad de cálculo y comprobación de hashes de AutoFirma 1.7. Las
operaciones de hashes ahora estarán disponibles a través de las opciones
de un menú.</p>
<ul>
<li>Vista de la barra de menús sin plugins instalados:</li>
</ul>
<p>&lt;<img src="media/image2.png"
style="width:6.12992in;height:0.70866in" /></p>
<ul>
<li>Vista de la barra de menús con el plugin de cálculo de hashes:</li>
</ul>
<p>&lt;<img src="media/image3.png"
style="width:6.21875in;height:0.71875in" /></p>
<ul>
<li>Vista de la barra de menús con el menú del plugin de cálculo de
    hashes desplegado:</li>
</ul>
<p>&lt;<img src="media/image4.png"
style="width:6.21875in;height:0.86458in" /></p>
<h2 id="nuevos-comandos">Nuevos comandos</h2>
<p>Los plugins permiten introducir nuevos comandos que un usuario pueda
utilizar al ejecutar AutoFirma desde línea de comandos. Una vez se
instala el plugin, los nuevos comandos estarán disponibles para su
ejecución tanto desde el ejecutable de AutoFirma (en todos los
sistemas), como desde AutoFirmaCommandLine (sólo en Windows).</p>
<p>El desarrollador del plugin tiene pleno control sobre la lógica de los
comandos implementados y será el encargado de definir toda la
funcionalidad, así como el tratamiento que debe hacer de sus parámetros.
El desarrollador es libre de definir los parámetros que desee para sus
comandos, aunque se recomienda por homogeneidad utilizar los mismos
parámetros que los comandos nativos de AutoFirma cuando ya existan para
indicar un tipo de parámetro concreto (datos de entrada, formato, etc).</p>
<p>&lt;<img src="media/image5.png"
style="width:6.21875in;height:3.03125in" /></p>
<h2 id="configuracion-de-los-plugins">Configuración de los <em>plugins</em></h2>
<p>Los <em>plugins</em> puede permitir o no su configuración al usuario. Por
ejemplo, un <em>plugin</em> que valide el certificado de firma utilizado contra
su <em>Distribution Point</em> (propiedad del propio certificado y en la que se
incluye la URL para su validación), podría no necesitar configuración
por parte del usuario. En cambio, un <em>plugin</em> que valide firmas contra
una plataforma externa de la que el usuario deba configurar sus
credenciales sí que lo necesitaría.</p>
<p>Las opciones de configuración de un <em>plugin</em> que lo permita se
encuentran en el diálogo de gestión de <em>plugins</em>. En esta pantalla se
mostrará un botón para el acceso a las opciones de configuración del
<em>plugin</em>.</p>
<p>La interfaz gráfica de configuración deberá proporcionarla el propio
<em>plugin</em> y desde esta se podrán definir y configurar las distintas
opciones. AutoFirma se encargará de almacenar las propiedades definidas,
no será necesario que lo haga el propio <em>plugin</em>, y se las proporcionará
a las distintas funciones del <em>plugins</em> (operaciones de preproceso de
los datos y postproceso de la firma, acciones asignadas a los distintos
botones definidos, etc.). Estas mismas opciones se devolverán a la
propia interfaz de configuración cuando se vuelva a abrir para que
muestre predefinidas las opciones configuradas.</p>
<h1 id="permisos-de-plugins">Permisos de plugins</h1>
<p>El sistema de plugins de AutoFirma define una serie de permisos con los
que se concede a los plugins permiso para integrarse de cada una de las
formas señaladas anteriormente. Los permisos de un plugin se declaran en
el fichero plugin.json del plugin, y AutoFirma no permitirá que un
plugin se integre de un poco concreto si este modo no estaba declarado
expresamente en este fichero.</p>
<p>AutoFirma mostrará al usuario los permisos declarados por el plugin
antes de proceder a su instalación y sólo lo instalará si el usuario da
su consentimiento.</p>
<p>Ejemplo de diálogo de solicitud de permisos:</p>
<p>&lt;<img src="media/image6.png"
style="width:4.02083in;height:3.39583in" /></p>
<p>Los permisos que puede solicitar un plugin son:</p>
<ul>
<li>
<p>Instalación: Permiso para implementar los métodos de instalación y
    desinstalación. Este es el método que permite hacer cambios en el
    equipo durante la instalación y la desinstalación del plugin.</p>
</li>
<li>
<p>Reinicio: Permiso para reiniciar la aplicación. Al conceder este
    permiso, tanto finalizar la instalación como la desinstalación, se
    reiniciará AutoFirma. Esto es necesario para poder aplicar los
    cambios de algunos modos de integración, como la integración de un
    nuevo menú.</p>
</li>
<li>
<p>Firma en línea: Permisos para implementar los métodos de
    preconfiguración y composición de la respuesta de los procesos de
    firma cuando se solicitan por protocolo.</p>
</li>
<li>
<p>Preprocesado: Permiso para procesar los datos antes de las
    operaciones de firma realizadas desde la interfaz gráfica.</p>
</li>
<li>
<p>Postprocesado: Permiso para procesar las firmas una vez generadas
    desde la interfaz gráfica de la aplicación.</p>
</li>
<li>
<p>Nuevos botones: Permisos para agregar botones a la interfaz de la
    aplicación.</p>
</li>
<li>
<p>Nuevo menú: Permisos para agregar un nuevo menú a la interfaz de la
    aplicación.</p>
</li>
<li>
<p>Nuevos comandos: Permisos para agregar nuevos comandos ejecutables
    por línea de comandos.</p>
</li>
</ul>
<h1 id="desarrollo-de-plugins">Desarrollo de <em>plugins</em></h1>
<p>Un <em>plugin</em> de AutoFirma es una biblioteca Java en la que una de sus
clases extiende la clase base de <em>plugins</em>. Para extender esta clase,
será necesario importar en nuestro proyecto el módulo que contiene las
clases base para el uso de los <em>plugins</em>. Un desarrollador puede
importar este módulo utilizando Apache Maven y la dependencia:</p>
<p>&lt;dependency&gt;</p>
<p>&lt;groupId&gt;es.gob.afirma&lt;/groupId&gt;</p>
<p>&lt;artifactId&gt;afirma-ui-simpleafirma-plugins&lt;/artifactId&gt;</p>
<p>&lt;version&gt;1.8.0&lt;/version&gt;</p>
<p>&lt;/dependency&gt;</p>
<p>AutoFirma es compatible con Java 8 y superiores. En concreto, las
distribuciones de 32bits de AutoFirma se incorpora Java 8 y las de
64bits con Java 11. Si deseamos que nuestros <em>plugins</em> sean compatibles
con todas las instalaciones de AutoFirma, deberán implementarse para ser
compatibles con Java 8.</p>
<p>Actualmente, AutoFirma sólo soporta <em>plugins</em> empaquetados en forma de
un único archivo JAR. Los <em>plugins</em> que se implementen deberán incluir
todas sus clases y dependencias en un único JAR o implementar por su
cuenta un mecanismo de carga de dependencias. Nunca se deben insertar en
el JAR del <em>plugin</em> las clases del módulo
“afirma-ui-simpleafirma-plugins” ni ninguna otra clase de AutoFirma, ya
que estas ya se encontrarán disponibles en la aplicación.</p>
<h2 id="construir-un-plugin">Construir un <em>plugin</em></h2>
<p>Como se ha mencionado, y salvo que se implementen mecanismos de carga
propios, un <em>plugin</em> se presenta en forma de un único JAR que contiene
todas las clases y recursos que necesita. Ya que en AutoFirma se pueden
cargar múltiples <em>plugins</em> simultáneamente y desconocemos donde
almacenarán sus recursos, cada <em>plugin</em> debería establecer un nombre de
paquete propio y agregar todas sus clases y recursos en dicho paquete.</p>
<p>Una vez importado el módulo, se deberán seguir los siguientes pasos para
desarrollar nuestro <em>plugin</em>:</p>
<ol>
<li><strong>Crear un fichero plugin.json</strong></li>
</ol>
<p>Este fichero se agregará al paquete que hayamos definido y contendrá los
metadatos de nuestro <em>plugin</em> y referencias a todos los elementos que
definen su comportamiento (botones que agrega, diálogo gráfico para su
configuración, etc). Este fichero deberá codificarse en UTF-8.</p>
<p>La estructura del JSON contendrá los elementos:</p>
<ul>
<li>
<p>info: Este contendrá los datos y la configuración del <em>plugin</em>. Los
    elementos que albergará son:</p>
<ul>
<li>
<p>name: Nombre interno del <em>plugin</em> (sin espacios).</p>
</li>
<li>
<p>title: Nombre legible del <em>plugin</em>.</p>
</li>
<li>
<p>version_code: Opcional. Número natural que identifica la versión
    del <em>plugin</em>. Por defecto, 1.</p>
</li>
<li>
<p>version: Opcional. Cadena con la versión del <em>plugin</em> en formato
    libre. Por defecto, “1.0”.</p>
</li>
<li>
<p>authors: Opcional. Lista con el nombre de los autores del
    <em>plugin</em>.</p>
</li>
<li>
<p>contacts: Opcional. Lista con la información de contacto de los
    autores.</p>
</li>
<li>
<p>description: Descripción del <em>plugin</em>.</p>
</li>
<li>
<p>configuration_panel: Opcional. Nombre de la clase que implementa
    el panel de configuración. Si no se indica, no habrá panel de
    configuración del <em>plugin</em>.</p>
</li>
</ul>
</li>
<li>
<p>permissions: Opcional. Listado de nombres de permiso que requiere el
    plugin. Los permisos disponibles son:</p>
<ul>
<li>
<p>INSTALL: Permiso para ejecutar código en la
    instalación/desinstalación del plugin.</p>
</li>
<li>
<p>RESET: Permiso para reiniciar AutoFIrma tras la
    instalación/desinstalación. El reinicio se realiza de forma
    automática.</p>
</li>
<li>
<p>INLINE_PROCESS: Permisos para modificar el procesado de las
    peticiones realizadas desde el navegador.</p>
</li>
<li>
<p>PRESIGN: Permiso para preprocesar los datos antes de una
    operación de firma a través de la interfaz de escritorio.</p>
</li>
<li>
<p>POSTSIGN: Permiso para postprocesar las firmas generadas en una
    operación de firma a través de la interfaz de escritorio.</p>
</li>
<li>
<p>BUTTONS: Permiso para agregar acciones a la interfaz de
    escritorio a través de botones.</p>
</li>
<li>
<p>MENU: Permiso para agregar un menú con acciones a la interfaz de
    escritorio.</p>
</li>
<li>
<p>COMMANDS: Permiso para agregar nuevos comandos para usar por
    línea de comandos.</p>
</li>
</ul>
</li>
<li>
<p>inline_processor: Opcional. Nombre de una clase que implementa
    es.gob.afirma.standalone.plugins.SignDataProcessor. Esta clase puede
    definir el modo de procesar los datos y la firma en una operación
    invocada desde un navegador web.</p>
</li>
<li>
<p>buttons: Opcional. Lista de botones que se deberán mostrar en la
    interfaz de AutoFirma. Cada botón define:</p>
<ul>
<li>
<p>title: Opcional. Texto que mostrar en el botón. El botón debería
    definir este atributo y/o un icono.</p>
</li>
<li>
<p>icon: Opcional. Imagen que mostrar en el botón a modo de icono.
    El botón debería definir este atributo y/o un texto.</p>
</li>
<li>
<p>tooltip: Opcional. Texto de ayuda que asociar al botón.</p>
</li>
<li>
<p>accesible_description: Opcional. Texto accesible que asociar al
    botón.</p>
</li>
<li>
<p>window: Ventana en la que mostrar el botón.</p>
</li>
<li>
<p>action: Nombre de la clase que define la acción a realizar por
    el botón.</p>
</li>
</ul>
</li>
<li>
<p>menu: Opcional. Nueva opción que se agregará a la barra de menús de
    AutoFirma. Puede contener un listado de opciones y submenús. Un menú
    define:</p>
<ul>
<li>
<p>title: Texto del menú. El texto del menú principal es el que se
    mostrara en la barra de menús de AutoFirma.</p>
</li>
<li>
<p>items: Opcional. Listado de submenús de este. Cada submenú se
    define igual que un menú.</p>
</li>
<li>
<p>action: Opcional. Nombre de la clase que define la acción a
    realizar por esta opción de menú. Si se declaró un listado de
    submenús para este menú, este no podrá tener una acción
    asociada.</p>
</li>
</ul>
</li>
<li>
<p>commands: Opcional. Listado de comandos que se agregaran para su uso
    por línea de comandos. Por cada uno de ellos se define:</p>
<ul>
<li>
<p>name: Nombre del comando.</p>
</li>
<li>
<p>description: Texto descriptivo de la operación.</p>
</li>
<li>
<p>action: Nombre de la clase que implementa el comando.</p>
</li>
</ul>
</li>
</ul>
<p>A continuación, se presenta la declaración formal del JSON mediante su
esquema (conforme al borrador 7 del documento de definición de esquemas
JSON):</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>{</p>
<p>"$schema": <em>"http://json-schema.org/draft-07/schema#"</em>,</p>
<p>"definitions": {</p>
<p>"info": {</p>
<p>"type": <em>"object"</em>,</p>
<p>"properties": {</p>
<p>"name": { "type": <em>"string"</em> },</p>
<p>"title": { "type": <em>"string"</em> },</p>
<p>"version_code": { "type": <em>"integer"</em>, "default": 1 },</p>
<p>"version": { "type": <em>"string"</em>, "default": <em>"1.0"</em>
},</p>
<p>"authors": {</p>
<p>"type": <em>"array"</em>,</p>
<p>"items": { "type": <em>"string"</em> },</p>
<p>"default": []</p>
<p>},</p>
<p>"contacts": {</p>
<p>"type": <em>"array"</em>,</p>
<p>"items": { "type": <em>"string"</em> },</p>
<p>"default": []</p>
<p>},</p>
<p>"description": { "type": <em>"string"</em> },</p>
<p>"configuration_panel": { "type": <em>"string"</em> }</p>
<p>},</p>
<p>"required": [<em>"name"</em>, <em>"title"</em>,
<em>"description"</em>]</p>
<p>},</p>
<p>"permissions": {</p>
<p>"type": <em>"array"</em>,</p>
<p>"items": {</p>
<p>"type": <em>"string"</em>,</p>
<p>"enum": [</p>
<p><em>"INSTALL"</em>,</p>
<p><em>"INLINE_PROCESS"</em>,</p>
<p><em>"RESET"</em>,</p>
<p><em>"PRESIGN"</em>,</p>
<p><em>"POSTSIGN"</em>,</p>
<p><em>"BUTTONS"</em>,</p>
<p><em>"MENU"</em>,</p>
<p><em>"COMMANDS"</em> ]</p>
<p>},</p>
<p>"default": []</p>
<p>},</p>
<p>"button": {</p>
<p>"type": <em>"object"</em>,</p>
<p>"properties": {</p>
<p>"title": { "type": <em>"string"</em> },</p>
<p>"icon": { "type": <em>"string"</em> },</p>
<p>"tooltip": { "type": <em>"string"</em> },</p>
<p>"accesible_description":{ "type": <em>"string"</em> },</p>
<p>"window": {</p>
<p>"type": {</p>
<p>"enum": [</p>
<p><em>"input"</em>,</p>
<p><em>"single_result"</em>,</p>
<p><em>"multi_result"</em>,</p>
<p><em>"visor"</em> ]</p>
<p>}</p>
<p>},</p>
<p>"action": { "type": <em>"string"</em> }</p>
<p>},</p>
<p>"required": [<em>"window"</em>, <em>"action"</em>]</p>
<p>}</p>
<p>},</p>
<p>"menu": {</p>
<p>"type": <em>"object"</em>,</p>
<p>"properties": {</p>
<p>"title": { "type": <em>"string"</em> },</p>
<p>"action": { "type": <em>"string"</em> },</p>
<p>"items": {</p>
<p>"type": <em>"array"</em>,</p>
<p>"items": { "$ref": <em>"#/definitions/menu"</em> },</p>
<p>"default": []</p>
<p>}</p>
<p>},</p>
<p>"required": [<em>"title"</em>]</p>
<p>},</p>
<p>"command": {</p>
<p>"type": <em>"object"</em>,</p>
<p>"properties": {</p>
<p>"name": { "type": <em>"string"</em> },</p>
<p>"description": { "type": <em>"string"</em> },</p>
<p>"action": { "type": <em>"string"</em> }</p>
<p>},</p>
<p>"required": [<em>"name"</em>, <em>"action"</em>]</p>
<p>}</p>
<p>"type": <em>"object"</em>,</p>
<p>"properties": {</p>
<p>"info": { "$ref": <em>"#/definitions/info"</em> },</p>
<p>"permissions": { "$ref": <em>"#/definitions/permissions"</em> },</p>
<p>"inline_processor": { "type": <em>"string"</em> },</p>
<p>"buttons": {</p>
<p>"type": <em>"array"</em>,</p>
<p>"items": { "$ref": <em>"#/definitions/button"</em> },</p>
<p>"default": []</p>
<p>},</p>
<p>"menu": { "$ref": <em>"#/definitions/menu"</em> },</p>
<p>"commands": {</p>
<p>"type": <em>"array"</em>,</p>
<p>"items": { "$ref": <em>"#/definitions/command"</em> },</p>
<p>"default": []</p>
<p>}</p>
<p>},</p>
<p>"required": [<em>"info"</em>]</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

<p>Un ejemplo de “plugin.json” sería:</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>{</p>
<p>"info":</p>
<p>{</p>
<p>"name" : <em>"validate_certs"</em>,</p>
<p>"title" : <em>"Validación de certificados"</em>,</p>
<p>"version_code" : 1,</p>
<p>"version" : <em>"1.0"</em>,</p>
<p>"authors" : [ <em>"Gobierno de España"</em> ],</p>
<p>"description" : <em>"Plugin para la comprobación del estado de
certificados de firma.&lt;br&gt;&lt;br&gt;Este plugin permite validar
los certificados utilizados para firmar con AutoFirma. La validación se
realiza mediante mecanismos predefinidos para los certificados de
algunos prestadores de servicios de confianza y, en caso de no tener
estos mecanismos predefinidos, contra la CRL o el OCSP declarado en el
propio certificado.&lt;br&gt;&lt;br&gt;Asegúrese de utilizar únicamente
certificados emitidos por prestadores de confianza para firmar, ya que
un certificado de un origen desconocido podría declarar mecanismos de
validación no seguros."</em></p>
<p>},</p>
<p>"permissions" : [ <em>"BUTTONS"</em> ],</p>
<p>"buttons" : [</p>
<p>{</p>
<p>"title" : <em>"Validar certificado de firma"</em>,</p>
<p>"icon" :
<em>"es/gob/afirma/plugin/certvalidation/certificate_16.png"</em>,</p>
<p>"tooltip" : <em>"Validar el certificado con el que se ha realizado la
firma"</em>,</p>
<p>"accesible_description" : <em>"Valida el certificado utilizado para
firmar"</em>,</p>
<p>"window" : <em>"single_result"</em>,</p>
<p>"action" :
<em>"es.gob.afirma.plugin.certvalidation.ValidateCertAction"</em></p>
<p>},</p>
<p>{</p>
<p>"title" : <em>"Validar certificado de firma"</em>,</p>
<p>"icon" :
<em>"es/gob/afirma/plugin/certvalidation/certificate_16.png"</em>,</p>
<p>"tooltip" : <em>"Validar el certificado con el que se ha realizado la
firma"</em>,</p>
<p>"accesible_description" : <em>"Valida el certificado utilizado para
firmar"</em>,</p>
<p>"window" : <em>"multi_result"</em>,</p>
<p>"action" :
<em>"es.gob.afirma.plugin.certvalidation.ValidateCertAction"</em></p>
<p>}</p>
<p>]</p>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

<p>Al instalar este <em>plugin</em> en AutoFirma, su aspecto en el diálogo de
gestión de <em>plugins</em> será:</p>
<p>&lt;<img src="media/image7.png"
style="width:6.20833in;height:5.70833in" /></p>
<ol>
<li><strong>Implementar AfirmaPlugin</strong></li>
</ol>
<p>Todo <em>plugin</em> deberá tener una clase que herede de AfirmaPlugin. Esta
será la clase principal del <em>plugin</em> y deberá encontrarse en el mismo
paquete que el fichero “plugin.json”. En esta clase se podrán
implementar los siguientes comportamientos:</p>
<ul>
<li>
<p>Instalación del <em>plugin</em>:</p>
<ul>
<li>Se ejecuta una única vez al importar el <em>plugin</em> en AutoFirma.
    Si fuese necesario, en él se deben configurar el sistema y
    preparar los recursos que requiera el <em>plugin</em> para su
    funcionamiento.</li>
</ul>
</li>
<li>
<p>Desinstalación del <em>plugin</em>:</p>
<ul>
<li>
<p>Se ejecuta una única vez al eliminar el <em>plugin</em> de AutoFirma.</p>
</li>
<li>
<p>En él se deben deshacer las opciones realizadas en el método de
    instalación.</p>
</li>
</ul>
</li>
<li>
<p>Preproceso de los datos</p>
<ul>
<li>
<p>Se ejecuta antes de la firma de cada uno de los datos de
    entrada.</p>
</li>
<li>
<p>Este método permite manipular o realizar operaciones en base a
    los datos que van a firmarse y devuelve los datos que realmente
    se firmarán.</p>
</li>
</ul>
</li>
<li>
<p>Postproceso de la firma</p>
<ul>
<li>
<p>Se ejecuta después de generar una firma electrónica y antes de
    almacenarla en disco.</p>
</li>
<li>
<p>Este método permite manipular la firma resultante o realizar
    operaciones en base a ella y devuelve los datos que finalmente
    se almacenarán en disco. También recibe el formato de firma
    utilizado y la cadena de certificación del certificado de firma.</p>
</li>
</ul>
</li>
<li>
<p>Fin de operación</p>
<ul>
<li>
<p>Se ejecuta después de haber finalizado la operación:</p>
<ul>
<li>
<p>En el caso de una firma simple, se ejecutará después del
    postprocesado de la firma.</p>
</li>
<li>
<p>En caso de una firma masiva, se ejecutará una única vez,
    tras haber postprocesado todas las firmas.</p>
</li>
</ul>
</li>
<li>
<p>Puede usarse si se almacena información en el proceso de
    postfirma que afecte a todas las firmas, para poder restablecer
    los datos a sus valores iniciales.</p>
<ul>
<li>Por ejemplo, en una firma masiva, se podría comprobar en el
    postprocesado si el usuario ha aceptado manipular la firma
    de alguna manera. Si aún no se le preguntó, se le pregunta;
    si ya se preguntó, se hace lo que se decidiera. En el método
    de fin de operación se eliminaría la respuesta del usuario
    para que en futuras operaciones se volviese a preguntar.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Para saber más sobre cómo implementar los métodos de instalación y
desinstalación del <em>plugin</em>, consulte el apartado <u>4.3 Métodos de
instalación y desinstalación</u>.</p>
<p>Para saber más sobre cómo implementar los métodos de preproceso de
datos, postproceso de firma y fin de la operación, consulte el apartado
<u>4.4 Métodos de preconfiguración y respuesta de las peticiones de
firma</u></p>
<p><u>Los plugins permiten definir un</u> mecanismo para tratar las firmas
electrónicas solicitadas por una aplicación externa mediante protocolo.
Estos métodos, a diferencia de los de prefirma y postfirma no tiene que
implementarse en la clase principal del plugin (AfirmaPlugin), sino en
una clase independiente que herede de la clase SignDataProcessor.</p>
<p>Para configurar el uso de esta clase, se deberá establecer la propiedad
“inline_processor” del fichero “plugin.json”.</p>
<p>La clase define varios métodos abstractos que se deberán implementar:</p>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li>
<ul>
<li>
<pre><code>-
</code></pre>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<h2 id="-">-</h2>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
<p><strong>boolean</strong> checkTrigger(SignOperation operation)Identifica cuando debe
activarse la operativa de este plugin. En el parámetro operation se
recibe toda la configuración de firma establecida.Si devuelve true, se
ejecutarán las funciones preProcess y postProcess sobre los datos de la
operación. Si devuelve false, no se ejecutarán y se consultará el
criterio del siguiente plugin de la lista.Criterios comunes de
activación que pueden usarse son:Se está procesando un dato concreto o
con un formato concreto. Por ejemplo:Se ha proporcionado un <em>token</em> de
autenticación concreto.Se ha proporcionado una cadena de datos Base64
concatenados con un separador en lugar de un Base 64 único.Se han
proporcionado propiedades específicas en el parámetro extraParams. Por
ejemplo:Se han proporcionado las propiedades necesarias para la firma
visible PDF.Se ha proporcionado una propiedad no recogida por AutoFirma
que se utiliza expresamente para la activación de este plugin.Se ha
proporcionado un parámetro distinto de los soportados por AutoFirma.
Estos parámetros se obtienen a través del método getAnotherParams() del
objeto operationList&lt;SignOperation&gt; preProcess(SignOperation
operation)Operación de preconfiguración.Esta operación se ejecuta antes
de la operación de firma y permite redefinir los parámetros de entrada
como un listado de parámetros del mismo tipo. Esto permite transformar
una operación de firma en muchas o redefinir los parámetros de la
operación.StringBuilder postProcess(List&lt;SignResult&gt; results,
SignOperation signOperation) <strong>throws</strong> EncryptingException,
PluginControlledExceptionOperación de composición de la respuesta de la
operación.Esta operación se ejecuta después de haber generado los
resultados de todas las operaciones de firma definidas.Recibe el
resultado de todas las operaciones de firma y la configuración de firma
original recibida por la aplicaciónDevuelve la cadena de texto que
devolver a la aplicación que solicitó la operación de firma.<strong>void</strong>
setCipherKey(<strong>byte</strong>[] key)Establece la clave de cifrado
proporcionada por la aplicación para que el plugin la aplique como
considere en la composición de la respuesta de la operación.<strong>boolean</strong>
isErrorsAllowed()Establece si, al procesar más de una firma, debería
interrumpirse la operación cuando falle al menos una de ellas. Para
permitir que un plugin modifique la operativa de las operaciones
solicitadas por una aplicación cliente, es necesario que declare el
permiso INLINE_PROCESS.</p>
<p>Métodos de prefirma y postfirma desde la interfaz gráfica.</p>
<p>Un <em>plugin</em> podría no sobrescribir ninguno de los métodos de
AfirmaPlugin si no actúa en ninguno de los procesos listados. En ese
caso, la clase aparecerá vacía y la interacción del usuario con el
<em>plugin</em> se deberá realizar a través de los botones declarados en
“plugin.json”. Un ejemplo de clase de este tipo sería:</p>
<p><strong>public</strong> <strong>class</strong> MiNuevoPlugin <strong>extends</strong> AfirmaPlugin {</p>
<p>// No se define ningun comportamiento especial para el plugin</p>
<p>}</p>
<ol>
<li><strong>Declarar un servicio AfirmaPlugin</strong></li>
</ol>
<p>Es necesario notificar a AutoFirma cuál de las clases de nuestra
biblioteca es la que implementa la clase AfirmaPlugin. Para hacer esto,
anunciaremos nuestra clase como servicio creando en el directorio
“META-INF/services” del proyecto el fichero
“es.gob.afirma.standalone.plugins.AfirmaPlugin”. El contenido de este
fichero debe ser el nombre completo de la clase que implementa
AfirmaPlugin.</p>
<p>Por ejemplo,</p>
<p>es.gob.afirma.plugin.certvalidation.ValidateCertsPlugin</p>
<h3 id="estructura-del-plugin">Estructura del <em>plugin</em></h3>
<p>Una vez se hayan seguido los pasos anteriores para la construcción
básica del <em>plugin</em>, la estructura mínima del proyecto debe ser la
siguiente:</p>
<p>&lt;<img src="media/image8.png"
style="width:3.425in;height:1.88333in" /></p>
<p>En el diagrama mostrado:</p>
<ul>
<li>
<p><strong>X</strong>, <strong>Y</strong> y <strong>Z</strong>, representan el paquete al que pertenece
    nuestro <em>plugin</em> y que no debería coincidir con el de ningún otro.</p>
</li>
<li>
<p>MiNuevoPlugin.java representa a la clase que implementa
    AfirmaPlugin.</p>
</li>
<li>
<p><strong>resources</strong> sería un directorio en el que podríamos almacenar los
    recursos (imágenes, ficheros de propiedades o cualquier otra cosa)
    que requiera nuestro <em>plugin</em>. Este directorio no tiene porqué
    existir, podría no haber recursos que almacenar o incluirse estos
    directamente en la estructura del paquete sin incluir un directorio
    adicional; podría tener cualquier otro nombre o podrían separarse
    los recursos en diversos directorios.</p>
</li>
</ul>
<p>En este caso, el contenido del fichero
“es.gob.afirma.standalone.plugins.AfirmaPlugin” sería:</p>
<p>X.Y.Z.MiNuevoPlugin</p>
<h2 id="opciones-de-configuracion">Opciones de configuración</h2>
<p>Diversos tipos de <em>plugins</em> podrían permitir al usuario configurar su
comportamiento incluso el configurarlos podría ser totalmente necesario
para su funcionamiento. Por ejemplo, un <em>plugin</em> podría permitir
configurar el algoritmo que utilizará al realizar una operación,
mientras que otro podría necesitar que el usuario configurase sus
credenciales para acceder a un almacén externo.</p>
<p>La configuración de todos los <em>plugins</em> deberá establecerse desde el
diálogo de gestión de <em>plugins</em>. Cuando un usuario seleccione un
<em>plugin</em> y este disponga de opciones configurables, se mostrará un botón
“Configurar”. Al pulsarlo, se mostrará al usuario un diálogo en el que
se mostrarán las opciones configurables.</p>
<p>La apariencia de este diálogo y las opciones que contiene se definirá
programáticamente mediante la herencia de la clase ConfigurationPanel.
Esta clase es un JPanel sobre el que se deberá construir la apariencia
del diálogo de configuración. Nuestra clase deberá ser pública e
implementar el constructor por defecto (sin parámetros), en el que se
agregarán los distintos componentes gráficos que se requieran para la
configuración (cajas de texto, listas de selección, cuadros de
verificación, etc.) estructurados en directamente en el panel, en
subpaneles o en pestañas según se desee.</p>
<p>La clase ConfigurationPanel deberá además implementar los siguientes
métodos:</p>
<ul>
<li>
<p>Properties getConfiguration()</p>
<ul>
<li>
<p>Este método construirá un objeto Properties en el que almacenará
    todos los valores configurados asignándoles un nombre de
    propiedad a cada uno de ellos.</p>
</li>
<li>
<p>El nombre asignado a cada opción de configuración y con el que
    se guarda en el Properties será el nombre con el que se podrá
    recuperar el valor durante la ejecución del <em>plugin</em>.</p>
</li>
<li>
<p>Todas las opciones configurables deberían tener una propiedad
    asignada, incluso si no se estableció un valor para ella, ya que
    el no hacerlo podría resultar en que se utilicen valores nulos
    al solicitar las opciones configuradas.</p>
</li>
<li>
<p>Este método se llama al aceptar el diálogo de selección de la
    configuración y se encarga de guardar todas las propiedades
    definidas.</p>
</li>
</ul>
</li>
<li>
<p><strong>void</strong> init(Properties config)</p>
<ul>
<li>
<p>Este método recibe un objeto Properties con los valores
    actualmente asignados a las opciones configurables. Si nunca se
    les ha asignado un valor, devolverá nulo.</p>
</li>
<li>
<p>En este método se deberían obtener los valores configurados en
    el objeto y establecerlos en las opciones de configuración de
    nuestro diálogo gráfico.</p>
</li>
<li>
<p>Las propiedades que definen el valor configurado para cada
    opción de configuración son las que se le hayan asignado en la
    llamada a getConfiguration().</p>
</li>
<li>
<p>Este método se llama al pulsar el botón “Configurar” para abrir
    el diálogo de configuración del <em>plugin</em>.</p>
</li>
</ul>
</li>
</ul>
<p>Un ejemplo de implementación de diálogo de configuración en el que se
permite la configuración de un cuadro de texto sería la siguiente:</p>
<p><strong>public</strong> <strong>class</strong> <u>MiDialogoConfiguracionPanel</u> <strong>extends</strong>
ConfigurationPanel {</p>
<p><strong>private</strong> <strong>static</strong> <strong>final</strong> String <strong><em>PROP_NOMBRE_FIRMANTE</em></strong> =
"nombreFirmante";</p>
<p><strong>private</strong> <strong>final</strong> JTextField tfNombreFirmante;</p>
<p><strong>public</strong> MiDialogoConfiguracionPanel() {</p>
<p>// Establecemos un layout</p>
<p>setLayout(<strong>new</strong> GridBagLayout());</p>
<p>// Construimos los distintos componentes graficos</p>
<p><strong>this</strong>.tfNombreFirmante = <strong>new</strong> JTextField();</p>
<p><strong>final</strong> JLabel lbNombreFirmante = <strong>new</strong> JLabel("Nombre del
firmante:");</p>
<p>lbNombreFirmante.setLabelFor(<strong>this</strong>.tfNombreFirmante);</p>
<p>// Posicionamos los componentes en el panel</p>
<p><strong>final</strong> GridBagConstraints c = <strong>new</strong> GridBagConstraints();</p>
<p>c.fill = GridBagConstraints.<strong><em>HORIZONTAL</em></strong>;</p>
<p>c.weightx = 1.0;</p>
<p>c.gridy = 0;</p>
<p>add(lbNombreFirmante, c);</p>
<p>c.gridy++;</p>
<p>add(<strong>this</strong>.tfNombreFirmante, c);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> <strong>void</strong> init(<strong>final</strong> Properties config) {</p>
<p>// Inicializamos el campo con el valor previamente configurado o con</p>
<p>// un valor por defecto si no se encontro</p>
<p>String nombre = config.getProperty(<strong><em>PROP_NOMBRE_FIRMANTE</em></strong>, "");</p>
<p><strong>this</strong>.tfNombreFirmante.setText(nombre);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Properties getConfiguration() {</p>
<p>// Creamos el objeto de propiedades y guardamos en el valor del</p>
<p>// campo que permitimos configurar</p>
<p><strong>final</strong> Properties config = <strong>new</strong> Properties();</p>
<p>config.setProperty(<strong><em>PROP_NOMBRE_FIRMANTE</em></strong>,
<strong>this</strong>.tfNombreFirmante.getText());</p>
<p><strong>return</strong> config;</p>
<p>}</p>
<p>}</p>
<p>Para poder indicar al <em>plugin</em> cuál es nuestra clase de diálogo de
configuración estableceremos el nombre de la clase en la propiedad
“configuration_panel” en el apartado “Info” del fichero “plugin.json”.</p>
<p>{</p>
<p>"info":</p>
<p>{</p>
<p>"name" : <em>"miplugin"</em>,</p>
<p>"title" : <em>"Inserción del nombre del firmante"</em>,</p>
<p>"version_code" : 1,</p>
<p>"version" : <em>"1.0"</em>,</p>
<p>"description" : <em>"Plugin de prueba"</em>,</p>
<p>"configuration_panel" : <em>"X.Y.Z.MiDialogoConfiguracionPanel"</em></p>
<p>}</p>
<p>…</p>
<p>Con un fichero “plugin.json” con el del ejemplo, se mostraría la
información del <em>plugin</em> y el botón de configuración como sigue:</p>
<p>&lt;<img src="media/image9.png"
style="width:6.20833in;height:5.70833in" /></p>
<p>En caso de implementar el diálogo de configuración como en el ejemplo,
al pulsar el botón de “Configurar” se mostraría:</p>
<p>&lt;<img src="media/image10.png"
style="width:1.95833in;height:1.36458in" /></p>
<h3 id="acceso-a-las-opciones-de-configuracion">Acceso a las opciones de configuración</h3>
<p>AutoFirma implementa un mecanismo para la recuperación de la
configuración del <em>plugin</em> desde cualquier punto de su código. Esto se
hará mediante la llamada al método getConfig() de las clases
AfirmaPlugin y PluginAction.</p>
<p>Properties getConfig()</p>
<p>Este método devuelve el conjunto de propiedades en el que hayamos
almacenado los valores establecidos en nuestro diálogo de configuración.</p>
<p>Así, por ejemplo, desde las acciones de preprocesado de datos,
postprocesado de firma o la acción de un botón, podemos hacer una
llamada solicitando las opciones de configuración que tenemos
establecidas:</p>
<p>@Override</p>
<p><strong>public</strong> <strong>byte</strong>[] postSignProcess(</p>
<p><strong>byte</strong>[] signature,</p>
<p>String format,</p>
<p>Certificate[] certChain)</p>
<p><strong>throws</strong> PluginControlledException {</p>
<p>String firmante = getConfig().getProperty(</p>
<p>MiDialogoConfiguracionPanel.<strong><em>PROP_NOMBRE_FIRMANTE</em></strong>);</p>
<p>…</p>
<p>}</p>
<h2 id="metodos-de-instalacion-y-desinstalacion">Métodos de instalación y desinstalación</h2>
<p>Los <em>plugins</em> permiten establecer un procedimiento de instalación y
desinstalación que preparen el sistema para su funcionamiento y lo
devuelvan a su estado original, respectivamente. Estos procedimientos se
implementan en la clase principal del <em>plugin</em>, extensión de
AfimaPlugin:</p>
<ul>
<li>
<p>Instalación del <em>plugin</em>:</p>
<ul>
<li>Genera o establece la configuración necesaria en el sistema para
    el funcionamiento del <em>plugin</em>.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>void</strong> install() <strong>throws</strong> PluginControlledException</p>
</blockquote>
<ul>
<li>
<p>Se ejecuta durante el proceso de importación del <em>plugin</em> en la
    aplicación.</p>
</li>
<li>
<p>En caso de error irrecuperable, se lanzaría una excepción de tipo
    PluginControlledException. En ese caso, se mostraría un mensaje de
    error al usuario, se desharían las tareas de instalación realizadas
    y se ejecutaría el proceso de desinstalación establecido por el
    propio <em>plugin</em>.</p>
</li>
</ul>
<!-- -->

<ul>
<li>
<p>Desinstalación del <em>plugin</em>:</p>
<ul>
<li>Deshace las acciones realizadas durante el proceso de
    instalación, además de eliminar cualquier otro recurso agregado
    o deshacer las acciones realizadas durante el funcionamiento del
    <em>plugin</em>.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>void</strong> uninstall() <strong>throws</strong> PluginControlledException</p>
</blockquote>
<ul>
<li>
<p>Se ejecuta durante el proceso de desinstalación de un <em>plugin</em>.</p>
</li>
<li>
<p>En caso de error irrecuperable, se lanzaría una excepción de tipo
    PluginControlledException. En ese caso, se mostraría un mensaje de
    error al usuario y se eliminaría el <em>plugin</em> de la aplicación,
    aunque no se completase el proceso.</p>
</li>
</ul>
<p>Para permitir que un plugin defina acciones a ejecutar durante la
instalación y desinstalación, es necesario que declare el permiso
INSTALL. Si adicionalmente se desea que se reinicie AutoFirma después de
la instalación y desinstalación, deberá declararse el permiso RESET.</p>
<h2 id="metodos-de-preconfiguracion-y-respuesta-de-las-peticiones-de-firma">Métodos de preconfiguración y respuesta de las peticiones de firma</h2>
<p>Los plugins permiten definir un mecanismo para tratar las firmas
electrónicas solicitadas por una aplicación externa mediante protocolo.
Estos métodos, a diferencia de los de prefirma y postfirma no tiene que
implementarse en la clase principal del plugin (AfirmaPlugin), sino en
una clase independiente que herede de la clase SignDataProcessor.</p>
<p>Para configurar el uso de esta clase, se deberá establecer la propiedad
“inline_processor” del fichero “plugin.json”.</p>
<p>La clase define varios métodos abstractos que se deberán implementar:</p>
<ul>
<li>
<p><strong>boolean</strong> checkTrigger(SignOperation operation)</p>
<ul>
<li>
<p>Identifica cuando debe activarse la operativa de este plugin. En
    el parámetro operation se recibe toda la configuración de firma
    establecida.</p>
</li>
<li>
<p>Si devuelve true, se ejecutarán las funciones preProcess y
    postProcess sobre los datos de la operación. Si devuelve false,
    no se ejecutarán y se consultará el criterio del siguiente
    plugin de la lista.</p>
</li>
<li>
<p>Criterios comunes de activación que pueden usarse son:</p>
<ul>
<li>
<p>Se está procesando un dato concreto o con un formato
    concreto. Por ejemplo:</p>
<ul>
<li>
<p>Se ha proporcionado un <em>token</em> de autenticación
    concreto.</p>
</li>
<li>
<p>Se ha proporcionado una cadena de datos Base64
    concatenados con un separador en lugar de un Base 64
    único.</p>
</li>
</ul>
</li>
<li>
<p>Se han proporcionado propiedades específicas en el parámetro
    extraParams. Por ejemplo:</p>
<ul>
<li>
<p>Se han proporcionado las propiedades necesarias para la
    firma visible PDF.</p>
</li>
<li>
<p>Se ha proporcionado una propiedad no recogida por
    AutoFirma que se utiliza expresamente para la activación
    de este plugin.</p>
</li>
</ul>
</li>
<li>
<p>Se ha proporcionado un parámetro distinto de los soportados
    por AutoFirma. Estos parámetros se obtienen a través del
    método getAnotherParams() del objeto operation</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>List&lt;SignOperation&gt; preProcess(SignOperation operation)</p>
<ul>
<li>
<p>Operación de preconfiguración.</p>
</li>
<li>
<p>Esta operación se ejecuta antes de la operación de firma y
    permite redefinir los parámetros de entrada como un listado de
    parámetros del mismo tipo. Esto permite transformar una
    operación de firma en muchas o redefinir los parámetros de la
    operación.</p>
</li>
</ul>
</li>
<li>
<p>StringBuilder postProcess(List&lt;SignResult&gt; results,
    SignOperation signOperation) <strong>throws</strong> EncryptingException,
    PluginControlledException</p>
<ul>
<li>
<p>Operación de composición de la respuesta de la operación.</p>
</li>
<li>
<p>Esta operación se ejecuta después de haber generado los
    resultados de todas las operaciones de firma definidas.</p>
</li>
<li>
<p>Recibe el resultado de todas las operaciones de firma y la
    configuración de firma original recibida por la aplicación</p>
</li>
<li>
<p>Devuelve la cadena de texto que devolver a la aplicación que
    solicitó la operación de firma.</p>
</li>
</ul>
</li>
<li>
<p><strong>void</strong> setCipherKey(<strong>byte</strong>[] key)</p>
<ul>
<li>Establece la clave de cifrado proporcionada por la aplicación
    para que el plugin la aplique como considere en la composición
    de la respuesta de la operación.</li>
</ul>
</li>
<li>
<p><strong>boolean</strong> isErrorsAllowed()</p>
<ul>
<li>Establece si, al procesar más de una firma, debería
    interrumpirse la operación cuando falle al menos una de ellas.</li>
</ul>
</li>
</ul>
<p>Para permitir que un plugin modifique la operativa de las operaciones
solicitadas por una aplicación cliente, es necesario que declare el
permiso INLINE_PROCESS.</p>
<h2 id="metodos-de-prefirma-y-postfirma-desde-la-interfaz-grafica">Métodos de prefirma y postfirma desde la interfaz gráfica</h2>
<p>Los métodos de preprocesado de los datos antes de firmarlos a través de
la interfaz gráfica, el de postprocesado de la firma antes de
almacenarla y el de fin de la operación de firma se implementan en la
clase principal del <em>plugin</em>, extensión de AfirmaPlugin:</p>
<ul>
<li>
<p>Preproceso de los datos:</p>
<ul>
<li>Procesa o actúa sobre los datos a firmar.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>byte</strong>[] preSignProcess(<strong>byte</strong>[] data, String format)</p>
</blockquote>
<p><strong>throws</strong> PluginControlledException</p>
<ul>
<li>
<p>Recibe los datos que van a firmarse y el formato de firma que se
    utilizará.</p>
</li>
<li>
<p>Devuelve los datos que finalmente se firmarán.</p>
</li>
<li>
<p>En caso de error irrecuperable, se lanzaría una excepción de tipo
    PluginControlledException. En ese caso, se mostraría un mensaje de
    error al usuario, pero el proceso de firma continuará normalmente.</p>
</li>
</ul>
<!-- -->

<ul>
<li>
<p>Postproceso de la firma:</p>
<ul>
<li>Procesa o actúa sobre la firma recién generada.</li>
</ul>
</li>
</ul>
<p><strong>byte</strong>[] postSignProcess(<strong>byte</strong>[] signature, String format,</p>
<blockquote>
<p>Certificate[] certChain) <strong>throws</strong> PluginControlledException</p>
</blockquote>
<ul>
<li>
<p>Recibe la firma generada, el formato de firma utilizado y la cadena
    de certificación del certificado con el que se ha firmado. La cadena
    de certificación podría no estar completa si no se encontrasen los
    certificados emisores en el almacén.</p>
</li>
<li>
<p>Devuelve la firma modificada.</p>
</li>
<li>
<p>En caso de error irrecuperable, se lanzaría una excepción de tipo
    PluginControlledException. En ese caso, se mostraría un mensaje de
    error al usuario, pero el proceso continuará normalmente con la
    firma original.</p>
</li>
</ul>
<!-- -->

<ul>
<li>
<p>Finalización del proceso de firma:</p>
<ul>
<li>Finaliza un proceso de firma simple o masiva, restableciendo lo
    que sea necesario para permitir una futura operación.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>void</strong> reset() <strong>throws</strong> PluginControlledException</p>
</blockquote>
<ul>
<li>En caso de error irrecuperable, se lanzaría una excepción de tipo
    PluginControlledException. En ese caso, se mostraría un mensaje de
    error al usuario, pero la aplicación continuaría funcionando
    normalmente.</li>
</ul>
<p>Para permitir que un plugin defina acciones a ejecutar para le
preproceso de los datos y el postproceso de la firma, es necesario que
declaren los permisos PRESIGN y POSTSIGN, respectivamente.</p>
<h2 id="botones-de-accion_1">Botones de acción</h2>
<p>Los botones de acción son botones que aparecen en diversas pantallas de
AutoFirma y que permiten realizar operaciones con la información cargada
en dicha pantalla, como los datos que se van a firmar o la firma que ya
se ha generado. Estos botones aparecen ordenados y en serie en una barra
de botones situada en la zona inferior de AutoFirma. Al pulsar un botón,
se desencadena la opción configurada.</p>
<p>Para el uso de botones de acción en un <em>plugin</em> es necesario realizar
los siguientes pasos:</p>
<ol>
<li><strong>Implementar la acción del botón</strong></li>
</ol>
<p>Las acciones de los botones se implementarán en clases Java que hereden
de la clase PluginAction. De esta clase se puede sobrescribir el
siguiente método para definir su comportamiento:</p>
<p><strong>void</strong> start(<strong>final</strong> Window parent)</p>
<p>Sin embargo, si se desea que nuestra acción utilice los datos cargados
en la pantalla de AutoFirma en la que se muestre, nuestra acción deberá
heredar de alguna de las clases hija de PluginAction:</p>
<ul>
<li>
<p>DataProcessAction: Permite utilizar los datos cargados en AutoFirma.</p>
</li>
<li>
<p>SignatureProcessAction: Permitir utilizar la firma generada o
    mostrada en AutoFirma y sus certificados.</p>
</li>
</ul>
<p>Según la pantalla en la que deseemos mostrar el botón, se deberá
implementar una u otra clase:</p>
<ul>
<li>
<p>Pantalla de carga de datos: DataProcessAction.</p>
</li>
<li>
<p>Pantalla con el resultado de una firma simple:
    SignatureProcessAction.</p>
</li>
<li>
<p>Pantalla con el resultado de una firma masiva:
    SignatureProcessAction.</p>
</li>
<li>
<p>Pantalla de visualización de datos de firma: SignatureProcessAction.</p>
</li>
</ul>
<p>Al heredar de la clase DataProcessAction se debe sobrescribir el método:</p>
<p><strong>void</strong> processData(InputData[] data, Window parent)</p>
<p>Este método recibe los datos de entrada de la pantalla y la ventana que
padre en la que se muestran.</p>
<ul>
<li>
<p>El listado de objetos de datos de entrada. Este listado contendrá un
    único elemento en las operaciones de firma simple y varios en las
    operaciones de firma masiva. Cada uno de estos objetos nos da acceso
    a:</p>
<ul>
<li>
<p>El fichero de datos cargado.</p>
</li>
<li>
<p>El formato de firma con el que se firmarían esos datos.</p>
</li>
</ul>
</li>
<li>
<p>La ventana padre nos sirve para utilizarla como ventana padre de
    cualquier diálogo gráfico que deseemos mostrar.</p>
</li>
</ul>
<p>Al heredar la clase SignatureProcessAction se debe sobrescribir el
método:</p>
<p><strong>void</strong> processSignatures(OutputData[] outputs, X509Certificate
signingCert,</p>
<blockquote>
<p>Window parent)</p>
</blockquote>
<p>Este método recibe los datos de salida de la pantalla, el certificado de
firma utilizado y la ventana que padre en la que se muestran los datos.</p>
<ul>
<li>
<p>El listado de objetos de datos de salida. Este listado contendrá un
    único elemento en las operaciones de firma simple y varios en las
    operaciones de firma masiva. Cada uno de estos objetos nos da acceso
    a:</p>
<ul>
<li>
<p>El fichero en el que se encuentra la firma. En caso de no
    existir, la firma debió finalizar con errores.</p>
</li>
<li>
<p>Si la firma terminó correctamente o no.</p>
</li>
<li>
<p>El formato de la firma.</p>
</li>
<li>
<p>Los certificados contenidos en la firma, que será el certificado
    utilizado en la firma (si se ha firmado) y los certificados de
    firmas previas.</p>
</li>
</ul>
</li>
<li>
<p>El certificado de firma nos permite saber con qué certificado ha
    firmado el usuario. Este parámetro podría llegar nulo si el usuario
    no hubiese firmado, por ejemplo, porque nos encontremos en la
    pantalla de visualización de firmas, en cuyo caso se cargó una firma
    que ya estaba hecha y no una que acabe de hacer el usuario.</p>
</li>
<li>
<p>La ventana padre nos sirve para utilizarla como ventana padre de
    cualquier diálogo gráfico que deseemos mostrar.</p>
</li>
</ul>
<p>Por ejemplo, si quisiéramos crear un <em>plugin</em> que permitiese validar los
certificados de firma, podríamos crear una clase que herede de
SignatureProcessAction, que implemente el método processSignatures(),
que tomase los certificados de la firma, los enviase a validar en base a
su <em>Distribution Point</em> y mostrase un mensaje al usuario con el
resultado de la validación.</p>
<ol>
<li><strong>Definir el aspecto del botón y la ventana en la que aparecerá</strong></li>
</ol>
<p>Una vez creada la acción del botón deberá registrarse en el <em>plugin</em>
para indicar dónde aparecerá y su aspecto. Esto se hará desde el
apartado “buttons” del fichero plugin.json.</p>
<p>Para cada uno de los botones se podrá definir los siguientes atributos:</p>
<ul>
<li>
<p>title: Opcional. Texto que mostrar en el botón. El botón debería
    definir este atributo y/o un icono.</p>
</li>
<li>
<p>icon: Opcional. Imagen que mostrar en el botón a modo de icono. El
    botón debería definir este atributo y/o un texto.</p>
</li>
<li>
<p>tooltip: Opcional. Texto de ayuda que asociar al botón.</p>
</li>
<li>
<p>accesible_description: Opcional. Texto accesible que asociar al
    botón para ser leído por lectores de pantalla. Su uso está
    especialmente indicado cuando el botón muestra un icono y no texto.</p>
</li>
<li>
<p>window: Ventana en la que mostrar el botón. Este atributo debe
    contener uno de los siguientes valores:</p>
<ul>
<li>
<p>input: El botón se mostrará en la pantalla de carga de datos.</p>
</li>
<li>
<p>single_result: El botón se mostrará en la pantalla de resultado
    de una operación firma simple.</p>
</li>
<li>
<p>multi_result: El botón se mostrará en la pantalla de resultado
    de una operación de firma masiva.</p>
</li>
<li>
<p>visor: El botón se mostrará en la pantalla en la que se
    visualizan los datos de la firma a través de la opción “Ver
    firma” o al abrir la firma desde el sistema operativo.</p>
</li>
</ul>
</li>
<li>
<p>action: Nombre de la clase que define la acción a realizar por el
    botón. Esta clase debe heredar de PluginAction o de alguna de las
    clases que herede de ella.</p>
</li>
</ul>
<p>Por ejemplo, la subestructura JSON para definir un único botón que
aparecería en la ventana del resultado de una firma simple sería:</p>
<p>…<br />
"buttons" : [</p>
<p>{</p>
<p>"title" : <em>"Validar certificado de firma"</em>,</p>
<p>"icon" : <em>"es/gob/afirma/plugin/certvalidation/certificate_16.png"</em>,</p>
<p>"tooltip" : <em>"Validar el certificado con el que se ha realizado la
firma"</em>,</p>
<p>"accesible_description" : <em>"Valida el certificado utilizado para
firmar"</em>,</p>
<p>"window" : <em>"single_result"</em>,</p>
<p>"action" : <em>"es.gob.afirma.plugin.certvalidation.ValidateCertAction"</em></p>
<p>}</p>
<p>]<br />
…</p>
<p>Si se desease que el botón apareciera en varias de las pantallas
admitidas sería necesario declararlo múltiples veces en el fichero
plugin.json.</p>
<p>Debe recordarse que, si se desean utilizar los datos disponibles en una
pantalla, nuestra acción deberá heredar de una clase concreta para esa
pantalla (DataProcessAction, SignatureProcessAction…) ya que es la que
recoge esos datos de la pantalla. Consulte en el paso 1 de este mismo
apartado la acción que deberá heredarse para poder utilizar los datos de
cada una de las pantallas que lo admiten.</p>
<p>En caso de querer realizar una misma acción desde diversas ventanas y
que los datos de entrada no sean necesarios, podríamos implementar
nuestra clase de acción heredando directamente de la clase PluginAction.</p>
<ol>
<li><strong>Otorgar el permiso para la integración de botones en la interfaz</strong></li>
</ol>
<p>En el fichero de declaración del plugin (plugin.json), se deberá
declarar el permiso BUTTONS.</p>
<h2 id="menu-de-opciones">Menú de opciones</h2>
<p>Un plugin puede agregar un único menú a la barra de menús de la
aplicación. Este menú puede definir varios submenús y/u opciones de menú
con acciones definidas. Los elementos del menú aparecen con el orden en
que se declararon en el fichero de configuración del plugin. Cada una de
las opciones del menú puede ser un submenú con nuevas opciones o tener
declarada una acción a ejecutar.</p>
<p>Para el uso de las opciones de menú en un <em>plugin</em> es necesario realizar
los siguientes pasos:</p>
<ol>
<li><strong>Implementar las acciones de las opciones del menú y sus submenús</strong></li>
</ol>
<p>Las acciones de las opciones de menú se implementarán en clases Java que
hereden de la clase PluginAction. De esta clase se puede sobrescribir el
siguiente método para definir su comportamiento:</p>
<p><strong>void</strong> start(<strong>final</strong> Window parent)</p>
<p>Este método recibe como parámetro de entrada la ventana de AutoFirma
para servidor como componente padre sobre el que mostrar cualquier
diálogo gráfico que sea necesario.</p>
<p>Por ejemplo, si quisiéramos que nuestro plugin mostrase un diálogo al
pulsar sobre alguna de sus opciones de menú, podríamos crear una clase
que herede de PluginAction, implemente el método start() y en él
construya y muestre el diálogo.</p>
<ol>
<li><strong>Definir la estructura y las opciones del menú</strong></li>
</ol>
<p>Una vez creadas todas las acciones del menú, deberemos definir la
estructura del mismo. Esto se hará desde el apartado “menu” del fichero
plugin.json.</p>
<p>Definiremos el atributo “menu” con un listado de elementos. Cada
elemento declarará un atributo “title” en el que se indicará el texto
que se mostrará en esa opción de menú. A su vez, cada elemento deberá
declarar uno de los siguientes atributos:</p>
<ul>
<li>
<p>items: Se usará cuando se desee que la nueva opción sea un submenú.
    Estos atributos declararán un nuevo listado de elementos de menú.</p>
</li>
<li>
<p>action: Se usará cuando se desee que sea la nueva opción tenga una
    acción asociada. Estos atributos declararán el nombre de la clase
    que implementa la acción que se desea desencadenar con esa opción.</p>
</li>
</ul>
<p>Por ejemplo, la subestructura JSON para definir un menú con dos submenús
y cada uno de ellos con dos opciones sería:</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>…</p>
<p>"menu": {</p>
<p>"title": <em>"Huellas digitales"</em>,</p>
<p>"items": [</p>
<p>{</p>
<p>"title": <em>"Fichero"</em>,</p>
<p>"items": [</p>
<p>{</p>
<p>"title": <em>"Calcular huella digital"</em>,</p>
<p>"action": <em>"es.gob.afirma.hash.CalculateHashFileAction"</em></p>
<p>},</p>
<p>{</p>
<p>"title": <em>"Comprobar huella digital"</em>,</p>
<p>"action": <em>"es.gob.afirma.hash.CheckHashFileAction"</em></p>
<p>}</p>
<p>]</p>
<p>},</p>
<p>{</p>
<p>"title": <em>"Directorio"</em>,</p>
<p>"items": [</p>
<p>{</p>
<p>"title": <em>"Calcular huella digital en directorio"</em>,</p>
<p>"action": <em>"es.gob.afirma.hash.CalculateHashDirAction"</em></p>
<p>},</p>
<p>{</p>
<p>"title": <em>"Comprobar huella digital en directorio"</em>,</p>
<p>"action": <em>"es.gob.afirma.hash.CheckHashDirAction"</em></p>
<p>}</p>
<p>]</p>
<p>}</p>
<p>]</p>
<p>},</p>
<p>…</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

<ol>
<li><strong>Otorgar el permiso para la integración de botones en la interfaz</strong></li>
</ol>
<p>En el fichero de declaración del plugin (plugin.json), se deberá
declarar el permiso MENU.</p>
<h2 id="comandos">Comandos</h2>
<p>Un plugin puede agregar múltiples comandos a AutoFirma para que puedan
ser ejecutados por línea de comandos. Estos comandos pueden implementar
la funcionalidad que se desee, aunque su finalidad suele ser la de
responder alguna de las siguientes necesidades:</p>
<ul>
<li>
<p>Permitir que un usuario calcule un resultado a través de la terminal
    de comandos del sistema.</p>
</li>
<li>
<p>Permitir que una aplicación externa se valga de AutoFirma para
    ejecutar una de las operativas que esta implementa. Esto puede ser
    mediante llamadas directas a la aplicación o mediante scripts del
    sistema.</p>
</li>
</ul>
<p>El sistema de plugin proporciona el modo de que los comandos agregados a
AutoFirma mediante plugins se listen junto al resto de comandos. Sin
embargo, cualquier acción o texto de ayuda propio del comando deberá ser
gestionado por el propio plugin.</p>
<p>Para el uso de las opciones de menú en un <em>plugin</em> es necesario realizar
los siguientes pasos:</p>
<ol>
<li><strong>Implementar las acciones de los comandos</strong></li>
</ol>
<p>Las acciones de los comandos se implementarán en clases Java que hereden
de la clase PluginCommandAction. De esta clase se deben implementar los
siguientes métodos para definir su comportamiento:</p>
<ul>
<li><strong>Constructor por defecto</strong>. Este constructor sin parámetros debería
    llamar al constructor de la clase padre que recibe una cadena y le
    debería pasar el propio nombre del comando. Por ejemplo, si mi clase
    de acción se llamase MiAction y se debiese ejecutar cuando se usase
    el comando “micomando”, el constructor sería:</li>
</ul>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p><strong>public</strong> MiAction() {</p>
<blockquote>
<p><strong>super</strong>(<u>"micomando"</u>);</p>
</blockquote>
<p>}</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

<ul>
<li>
<p><strong>Método</strong>: String getHelpText()</p>
<ul>
<li>
<p>Este método debería devolver una cadena de ayuda con la sintaxis
    que admite el comando y una explicación sobre los distintos
    parámetros de configuración.</p>
</li>
<li>
<p>A modo orientativo, cuando AutoFirma muestra la sintaxis de un
    comando lo hace mediante un texto con la siguiente forma:</p>
</li>
</ul>
</li>
</ul>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Sintaxis:</p>
<p>··AutoFirma·COMANDO·SINTAXIS-·DESCRIPCION</p>
<p>Parámetros:</p>
<p>··PARAMETRO1(DESCRIPCION_PARAMETRO1)</p>
<p>··PARAMETRO2(DESCRIPCION_PARAMETRO2)</p>
<p>…</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

<blockquote>
<p>En la sintaxis anterior, los puntos a media altura simbolizan espacios
y las flechas a la derecha simbolizan tabuladores. La cantidad de
tabuladores necesaria para alinear los elementos puede variar según la
longitud de los textos.</p>
<p>Los elementos incluidos en la estructura anterior son:</p>
</blockquote>
<ul>
<li>
<p>COMANDO: Nombre del comando.</p>
</li>
<li>
<p>SINTAXIS: Estructura de la sintaxis (opciones parámetros)</p>
</li>
<li>
<p>DESCRIPCION: Descripción del comando</p>
</li>
<li>
<p>En caso de que hubiese varios formatos de sintaxis, se podría
    repetir esta línea con los distintos formatos.</p>
</li>
<li>
<p>PARAMETROX: Identificador del parámetro.</p>
</li>
<li>
<p>DESCRIPCION_PARAMETROX: Descripción de la funcionalidad del
    parámetro.</p>
</li>
</ul>
<!-- -->

<ul>
<li>
<p><strong>Método</strong>: String process(String[] args) <strong>throws</strong>
    PluginControlledException</p>
<ul>
<li>
<p>Este método recibe como parámetro el listado de argumentos
    proporcionado en la llamada a AutoFirma. Los parámetros
    recibidos no contendrán el nombre del ejecutable de AutoFirma o
    el propio comando ejecutado, sólo los parámetros que este
    recibió.</p>
</li>
<li>
<p>La excepción PluginControlledException se debería lanzar cuando
    falle la ejecución del comando. Se mostrará al usuario el
    mensaje incluido en esta excepción.</p>
</li>
<li>
<p>El plugin tiene control total sobre su comportamiento, aunque se
    recomienda seguir las siguientes directrices por homogeneidad
    con el resto de los comandos de Autofirma:</p>
<ul>
<li>
<p>Si el primer argumento recibido se corresponde con la cadena
    “-help” o si el comando recibe un conjunto de parámetros no
    válidos, se debería llamar a getHelpText() para devolver el
    texto de ayuda.</p>
</li>
<li>
<p>Utilizar los mismos parámetros que el resto de los comandos
    de AutoFirma. Algunos ejemplos son:</p>
<ul>
<li>
<p>“-i” y “-o” para designar el fichero de entrada y
    salida.</p>
</li>
<li>
<p>“-xml” para determinar que la salida se estructure en
    forma de XML.</p>
</li>
<li>
<p>“-gui” si se desea que el comando utilice interfaz
    gráfica para solicitar datos.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><strong>Declarar los comandos</strong></li>
</ol>
<p>Una vez definido el comportamiento de los comandos, deberemos
declararlos en el fichero plugin.json.</p>
<p>Los comandos se definirán bajo un nuevo apartado “commands” en el que se
listarán los nuevos comandos. De cada uno de los comandos deberemos
definir los atributos:</p>
<ul>
<li>
<p>name: Nombre del comando que se deberá usar por línea de comandos.</p>
</li>
<li>
<p>description: Descripción del comando (se mostrará al ejecutar la
    ayuda de AutoFirma por línea de comandos).</p>
</li>
<li>
<p>action: Nombre de la clase que hereda de PluginCommandAction e
    implementa la lógica del comando.</p>
</li>
</ul>
<p>Una subestructura JSON de ejemplo que defina dos comandos podría ser la
siguiente:</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><p>…</p>
<p>"commands": [</p>
<p>{</p>
<p>"name": <em>"createdigest"</em>,</p>
<p>"description": <em>"Creación de huellas digitales con interfaz
gráfica"</em>,</p>
<p>"action":
<em>"es.gob.afirma.plugin.hash.command.CreateHashCommand"</em></p>
<p>},</p>
<p>{</p>
<p>"name": <em>"checkdigest"</em>,</p>
<p>"description": <em>"Comprobación de huellas digitales con interfaz
gráfica"</em>,</p>
<p>"action":
<em>"es.gob.afirma.plugin.hash.command.CheckHashCommand"</em></p>
<p>}</p>
<p>],</p>
<p>…</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>

<ol>
<li><strong>Otorgar el permiso para agregar nuevos comandos a la aplicación</strong></li>
</ol>
<p>En el fichero de declaración del plugin (plugin.json), se deberá
declarar el permiso COMMANDS.</p>
<h1 id="empaquetado-de-los-plugins">Empaquetado de los <em>plugins</em></h1>
<p>Los plugins deben distribuirse en forma de un único archivo JAR con toda
la operativa del plugin en su interior. En caso de tener dependencias
con otras clases no incluidas en AutoFirma, deberán importarse en el
propio archivo. En caso de tener dependencias con clases de AutoFirma,
estas no deberían incluirse en el JAR.</p>
<h2 id="firma-de-los-plugins">Firma de los plugins</h2>
<p>Los plugins podrán firmarse mediante el proceso de firma del JAR que lo
integra. La firma del JAR se realizará conforme a los requisitos
establecidos por Oracle:</p>
<p><a href="https://docs.oracle.com/javase/tutorial/deployment/jar/signing.html">https://docs.oracle.com/javase/tutorial/deployment/jar/signing.html</a></p>
<p>Antes de proceder a la instalación de un plugin, AutoFirma comprueba su
firma. Durante esta comprobación pueden surgir tres situaciones
distintas:</p>
<ul>
<li>
<p>El plugin está correctamente firmado. En ese caso, se le indicará al
    usuario por quién está firmado el plugin según el certificado
    utilizado. Además, se le permitirá extraer el certificado de firma
    por si el usuario quiere validar el certificado o realizar
    comprobaciones adicionales.</p>
<ul>
<li>AutoFirma no comprueba la confianza en el certificado firmante.</li>
</ul>
</li>
<li>
<p>El plugin no se encuentra firmado. En ese caso, se indica la
    situación al usuario.</p>
</li>
<li>
<p>La firma del plugin presenta errores. En ese caso, se informa al
    usuario del error.</p>
</li>
</ul>
<p>Ejemplo de diálogo con la información de la firma de un plugin:</p>
<p>&lt;<img src="media/image11.png"
style="width:5.55208in;height:1.83333in" /></p>
<p>En todos los casos el usuario puede continuar el proceso de firma del
plugin indicando si confía o no en el mismo.</p>
<h1 id="preguntas-y-respuestas">Preguntas y respuestas</h1>
<h2 id="es-posible-realizar-la-instalacion-masiva-de-un-plugin-en-los-equipos-de-mis-usuarios">¿Es posible realizar la instalación masiva de un <em>plugin</em> en los equipos de mis usuarios?</h2>
<p>No existe un mecanismo particular para la instalación masiva de
<em>plugins</em> de AutoFirma. Para realizar esto, sería necesario copiar al
equipo de los usuarios objetivos el fichero con el <em>plugin</em> y modificar
el fichero con la relación de <em>plugins</em> instalados.</p>
<p>El directorio de instalación de los <em>plugins</em> varia de un sistema a
otro:</p>
<ul>
<li>
<p>Directorio Windows:</p>
<ul>
<li>%ALLUSERSPROFILE%/AutoFirma</li>
</ul>
</li>
<li>
<p>Directorio Linux:</p>
<ul>
<li>~/AutoFirma.</li>
</ul>
</li>
<li>
<p>Directorio macOS:</p>
<ul>
<li>~/Library/Application Support/AutoFirma</li>
</ul>
</li>
</ul>
<p>En esos directorios se crea un subdirectorio “plugins” y dentro del
mismo se sitúa un fichero con el listado de <em>plugins</em> instalados
(installed) y un directorio por cada <em>plugin</em>. Para instalar
programáticamente cada <em>plugin</em> es necesario:</p>
<ol>
<li>
<p>Crear dentro del directorio “plugins” un subdirectorio con el nombre
    interno del <em>plugin</em> que deseamos instalar (el nombre indicado en la
    propiedad “name” de su “plugin.json”).</p>
</li>
<li>
<p>Copiar el JAR del <em>plugin</em> al directorio creado para el mismo.</p>
</li>
<li>
<p>Agregar al fichero “installed” una nueva línea con el nombre del
    <em>plugin</em> instalado y su número de versión (tal como se indica en la
    propiedad “version_code” de su “plugin.json”).</p>
</li>
</ol>
<p>La estructura resultante sería:</p>
<p>&lt;<img src="media/image12.png"
style="width:3.91667in;height:1.15in" /></p>
<p>El contenido del fichero “installed”, en este caso, podría ser:</p>
<p>validate_certs:1</p>
<p>&lt;<img src="media/image13.png"
style="width:0.91667in;height:0.32292in"
alt="Creative Commons License" /></p>
<p>Esta obra está bajo una licencia <a href="#Licencia_Creative_Commons">Creative Commons
Reconocimiento-NoComercial-CompartirIgual 3.0
Unported</a>.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../AF_Instalador%20Windows/" class="btn btn-neutral float-left" title="AF Instalador Windows"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../AF_manual_instalacion_usuarios_ES/" class="btn btn-neutral float-right" title="AF manual instalacion usuarios ES">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../AF_Instalador%20Windows/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../AF_manual_instalacion_usuarios_ES/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
